# -*- coding: utf-8 -*-
"""Curvetopia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17QAZXp3OffsTom3zSb5xH6OBs3ybw3xM
"""

pip install numpy matplotlib svgwrite cairosvg

import numpy as np

def read_csv(csv_path):
    try:
        np_path_XYs = np.genfromtxt(csv_path, delimiter=',', skip_header=1)  # Skip header if needed
        print(np_path_XYs)  # Print the contents for debugging
        path_XYs = []
        for i in np.unique(np_path_XYs[:, 0]):
            npXYs = np_path_XYs[np_path_XYs[:, 0] == i][:, 1:]
            XYs = []
            for j in np.unique(npXYs[:, 0]):
                XY = npXYs[npXYs[:, 0] == j][:, 1:]
                XYs.append(XY)
            path_XYs.append(XYs)
        return path_XYs
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        return None

# Example usage
path_XYs = read_csv('master_doodle_dataframe.csv')
if path_XYs is not None:
    plot(path_XYs)
    polylines2svg(path_XYs, 'output.svg')

import numpy as np
import matplotlib.pyplot as plt
import svgwrite
import cairosvg

# Step 3: Regularize Curves
def regularize_curves(path_XYs):
    # Placeholder: Implement curve regularization logic
    # You can add functions to identify straight lines, circles, ellipses, rectangles, etc.
    # and modify the XY coordinates accordingly.
    print("Regularizing curves...")
    # Example: Loop through each path and apply regularization algorithms
    for path in path_XYs:
        for XY in path:
            # Apply regularization (e.g., fit lines or circles)
            pass  # Replace with actual implementation
    return path_XYs

# Step 4: Explore Symmetry
def detect_symmetry(path_XYs):
    # Placeholder: Implement symmetry detection logic
    print("Detecting symmetry...")
    for path in path_XYs:
        for XY in path:
            # Apply symmetry detection (e.g., check for reflectional or rotational symmetry)
            pass  # Replace with actual implementation
    return path_XYs

# Step 5: Complete Incomplete Curves
def complete_curves(path_XYs):
    # Placeholder: Implement curve completion algorithm
    print("Completing incomplete curves...")
    for path in path_XYs:
        for XY in path:
            # Apply curve completion logic
            pass  # Replace with actual implementation
    return path_XYs

# Step 6: Convert to SVG and Rasterize
def polylines2svg(path_XYs, svg_path):
    if path_XYs is None:
        print("No data to convert to SVG.")
        return
    W, H = 0, 0
    for path in path_XYs:
        for XY in path:
            W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))
    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()
    for i, path in enumerate(path_XYs):
        path_data = []
        for XY in path:
            path_data.append(("M", (XY[0, 0], XY[0, 1])))
            for j in range(1, len(XY)):
                path_data.append(("L", (XY[j, 0], XY[j, 1])))
            if not np.allclose(XY[0], XY[-1]):
                path_data.append(("Z", None))
        group.add(dwg.path(d=path_data, stroke='black', stroke_width=2))
    dwg.add(group)
    dwg.save()
    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(url=svg_path, write_to=png_path, parent_width=W, parent_height=H, output_width=fact * W, output_height=fact * H, background_color='white')

# Example usage
path_XYs = read_csv('master_doodle_dataframe.csv')
if path_XYs is not None:
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    path_XYs = complete_curves(path_XYs)
    plot(path_XYs)
    polylines2svg(path_XYs, 'output.svg')

import numpy as np
import matplotlib.pyplot as plt
import svgwrite
import cairosvg

# Step 1: Load CSV Data
def read_csv(csv_path):
    np_path_XYs = np.genfromtxt(csv_path, delimiter=',')
    path_XYs = []
    for i in np.unique(np_path_XYs[:, 0]):
        npXYs = np_path_XYs[np_path_XYs[:, 0] == i][:, 1:]
        XYs = []
        for j in np.unique(npXYs[:, 0]):
            XY = npXYs[npXYs[:, 0] == j][:, 1:]
            XYs.append(XY)
        path_XYs.append(XYs)
    return path_XYs

def write_csv(csv_path, path_XYs):
    with open(csv_path, 'w') as f:
        for path in path_XYs:
            for XY in path:
                for coord in XY:
                    f.write(f"{coord[0]},{coord[1]}\n")

# Step 2: Visualize Shapes
def plot(path_XYs, title='Plot'):
    fig, ax = plt.subplots(tight_layout=True, figsize=(8, 8))
    for i, XYs in enumerate(path_XYs):
        for XY in XYs:
            ax.plot(XY[:, 0], XY[:, 1], linewidth=2)
    ax.set_aspect('equal')
    plt.title(title)
    plt.show()

# Step 3: Regularize Curves
def regularize_curves(path_XYs):
    # Placeholder for regularizing logic
    return path_XYs

# Step 4: Explore Symmetry
def detect_symmetry(path_XYs):
    # Placeholder for symmetry detection logic
    return path_XYs

# Step 5: Complete Incomplete Curves
def complete_curves(path_XYs):
    # Placeholder for curve completion logic
    return path_XYs

# Step 6: Convert to SVG and Rasterize
def polylines2svg(path_XYs, svg_path):
    if path_XYs is None:
        print("No data to convert to SVG.")
        return
    W, H = 0, 0
    for path in path_XYs:
        for XY in path:
            W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))
    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()
    for i, path in enumerate(path_XYs):
        path_data = []
        for XY in path:
            path_data.append(("M", (XY[0, 0], XY[0, 1])))
            for j in range(1, len(XY)):
                path_data.append(("L", (XY[j, 0], XY[j, 1])))
            if not np.allclose(XY[0], XY[-1]):
                path_data.append(("Z", None))
        group.add(dwg.path(d=path_data, stroke='black', stroke_width=2))
    dwg.add(group)
    dwg.save()
    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(url=svg_path, write_to=png_path, parent_width=W, parent_height=H, output_width=fact * W, output_height=fact * H, background_color='white')

# Processing isolated shapes
def process_isolated_shapes(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Processing fragmented shapes
def process_fragmented_shapes(input_csvs, output_csv):
    path_XYs_combined = []
    for input_csv in input_csvs:
        path_XYs = read_csv(input_csv)
        path_XYs_combined.extend(path_XYs)
    path_XYs_combined = regularize_curves(path_XYs_combined)
    path_XYs_combined = detect_symmetry(path_XYs_combined)
    write_csv(output_csv, path_XYs_combined)

# Processing connected occlusion shapes
def process_connected_occlusion(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Processing disconnected occlusion shapes
def process_disconnected_occlusion(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Example of processing based on the input categories:

# Isolated Shapes
process_isolated_shapes('master_doodle_dataframe.csv', 'examples/isolated_sol.csv')

# Fragmented Shapes
process_fragmented_shapes(['examples/frag0.csv', 'examples/frag1.csv'], 'examples/frag01_sol.csv')
process_fragmented_shapes(['examples/frag2.csv'], 'examples/frag2_sol.csv')

# Connected Occlusion
process_connected_occlusion('examples/occlusion1.csv', 'examples/occlusion1_sol.csv')

# Disconnected Occlusion
process_disconnected_occlusion('examples/occlusion2.csv', 'examples/occlusion2_sol.csv')

# Generate SVG and PNG
path_XYs = read_csv('examples/isolated_sol.csv')
polylines2svg(path_XYs, 'output_isolated.svg')

path_XYs = read_csv('examples/frag01_sol.csv')
polylines2svg(path_XYs, 'output_fragmented.svg')

path_XYs = read_csv('examples/occlusion1_sol.csv')
polylines2svg(path_XYs, 'output_connected_occlusion.svg')

path_XYs = read_csv('examples/occlusion2_sol.csv')
polylines2svg(path_XYs, 'output_disconnected_occlusion.svg')

import os

# Create the 'examples' directory if it doesn't exist
if not os.path.exists('examples'):
    os.makedirs('examples')

def write_csv(csv_path, path_XYs):
    # Ensure directory exists
    directory = os.path.dirname(csv_path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory)

    with open(csv_path, 'w') as f:
        for path in path_XYs:
            for XY in path:
                for coord in XY:
                    f.write(f"{coord[0]},{coord[1]}\n")

print(os.listdir('.'))

from google.colab import files
import os

# Ensure the 'examples' directory exists (change path if needed)
output_dir = 'examples'
if not os.path.exists(output_dir):
    print(f"Directory '{output_dir}' does not exist.")
else:
    print(f"Files in '{output_dir}': {os.listdir(output_dir)}")

# List the files you want to download
files_to_download = [
    'examples/isolated_sol.csv',
    'examples/frag01_sol.csv',
    'examples/frag2_sol.csv',
    'examples/occlusion1_sol.csv',
    'examples/occlusion2_sol.csv'
]

# Download each file if it exists
for file in files_to_download:
    file_path = os.path.join(output_dir, file.split('/')[-1])
    if os.path.exists(file_path):
        files.download(file_path)
    else:
        print(f"File '{file_path}' not found.")

import os

# Create the 'examples' directory if it doesn't exist
output_dir = 'examples'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)
    print(f"Directory '{output_dir}' created.")
else:
    print(f"Directory '{output_dir}' already exists.")

# Assume the processing functions and the path to 'master_doodle_dataframe.csv' are defined

# Generating solution files
process_isolated_shapes('master_doodle_dataframe.csv', 'examples/isolated_sol.csv')
process_fragmented_shapes(['examples/frag0.csv', 'examples/frag1.csv'], 'examples/frag01_sol.csv')
process_fragmented_shapes(['examples/frag2.csv'], 'examples/frag2_sol.csv')
process_connected_occlusion('examples/occlusion1.csv', 'examples/occlusion1_sol.csv')
process_disconnected_occlusion('examples/occlusion2.csv', 'examples/occlusion2_sol.csv')

print("Solution files have been generated.")

from google.colab import files

# Verify the files exist in the 'examples' directory
print(f"Files in '{output_dir}': {os.listdir(output_dir)}")

# List the files you want to download
files_to_download = [
    'examples/isolated_sol.csv',
    'examples/frag01_sol.csv',
    'examples/frag2_sol.csv',
    'examples/occlusion1_sol.csv',
    'examples/occlusion2_sol.csv'
]

# Download each file if it exists
for file in files_to_download:
    file_path = os.path.join(output_dir, file.split('/')[-1])
    if os.path.exists(file_path):
        files.download(file_path)
    else:
        print(f"File '{file_path}' not found.")

import os

# List all files in the current directory
print("Files in the current directory:", os.listdir('.'))

# Check if the 'master_doodle_dataframe.csv' exists
if os.path.exists('master_doodle_dataframe.csv'):
    print("'master_doodle_dataframe.csv' exists.")
else:
    print("'master_doodle_dataframe.csv' not found.")

# Similarly, check for other required files
required_files = ['examples/frag0.csv', 'examples/frag1.csv', 'examples/frag2.csv', 'examples/occlusion1.csv', 'examples/occlusion2.csv']

for file in required_files:
    if os.path.exists(file):
        print(f"'{file}' exists.")
    else:
        print(f"'{file}' not found.")

from google.colab import files

# Upload any missing files
uploaded = files.upload()

# After uploading, check if the files are present
print("Files in the current directory after upload:", os.listdir('.'))

import os

# List all files in the current directory
print("Files in the current directory:", os.listdir('.'))

# Check if the 'master_doodle_dataframe.csv' exists
if os.path.exists('master_doodle_dataframe.csv'):
    print("'master_doodle_dataframe.csv' exists.")
else:
    print("'master_doodle_dataframe.csv' not found.")

# Check for other required files
required_files = ['examples/frag0.csv', 'examples/frag1.csv', 'examples/frag2.csv', 'examples/occlusion1.csv', 'examples/occlusion2.csv']

for file in required_files:
    if os.path.exists(file):
        print(f"'{file}' exists.")
    else:
        print(f"'{file}' not found.")

# Ensure the 'examples' directory exists
if not os.path.exists('examples'):
    os.makedirs('examples')

import numpy as np
import matplotlib.pyplot as plt
import svgwrite
import cairosvg

# Step 1: Load CSV Data
def read_csv(csv_path):
    np_path_XYs = np.genfromtxt(csv_path, delimiter=',')
    path_XYs = []
    for i in np.unique(np_path_XYs[:, 0]):
        npXYs = np_path_XYs[np_path_XYs[:, 0] == i][:, 1:]
        XYs = []
        for j in np.unique(npXYs[:, 0]):
            XY = npXYs[npXYs[:, 0] == j][:, 1:]
            XYs.append(XY)
        path_XYs.append(XYs)
    return path_XYs

def write_csv(csv_path, path_XYs):
    with open(csv_path, 'w') as f:
        for path in path_XYs:
            for XY in path:
                for coord in XY:
                    f.write(f"{coord[0]},{coord[1]}\n")

# Step 2: Visualize Shapes
def plot(path_XYs, title='Plot'):
    fig, ax = plt.subplots(tight_layout=True, figsize=(8, 8))
    for i, XYs in enumerate(path_XYs):
        for XY in XYs:
            ax.plot(XY[:, 0], XY[:, 1], linewidth=2)
    ax.set_aspect('equal')
    plt.title(title)
    plt.show()

# Step 3: Regularize Curves
def regularize_curves(path_XYs):
    # Placeholder for regularizing logic
    return path_XYs

# Step 4: Explore Symmetry
def detect_symmetry(path_XYs):
    # Placeholder for symmetry detection logic
    return path_XYs

# Step 5: Complete Incomplete Curves
def complete_curves(path_XYs):
    # Placeholder for curve completion logic
    return path_XYs

# Step 6: Convert to SVG and Rasterize
def polylines2svg(path_XYs, svg_path):
    if path_XYs is None:
        print("No data to convert to SVG.")
        return
    W, H = 0, 0
    for path in path_XYs:
        for XY in path:
            W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))
    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()
    for i, path in enumerate(path_XYs):
        path_data = []
        for XY in path:
            path_data.append(("M", (XY[0, 0], XY[0, 1])))
            for j in range(1, len(XY)):
                path_data.append(("L", (XY[j, 0], XY[j, 1])))
            if not np.allclose(XY[0], XY[-1]):
                path_data.append(("Z", None))
        group.add(dwg.path(d=path_data, stroke='black', stroke_width=2))
    dwg.add(group)
    dwg.save()
    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(url=svg_path, write_to=png_path, parent_width=W, parent_height=H, output_width=fact * W, output_height=fact * H, background_color='white')

# Processing isolated shapes
def process_isolated_shapes(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Processing fragmented shapes
def process_fragmented_shapes(input_csvs, output_csv):
    path_XYs_combined = []
    for input_csv in input_csvs:
        path_XYs = read_csv(input_csv)
        path_XYs_combined.extend(path_XYs)
    path_XYs_combined = regularize_curves(path_XYs_combined)
    path_XYs_combined = detect_symmetry(path_XYs_combined)
    write_csv(output_csv, path_XYs_combined)

# Processing connected occlusion shapes
def process_connected_occlusion(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Processing disconnected occlusion shapes
def process_disconnected_occlusion(input_csv, output_csv):
    path_XYs = read_csv(input_csv)
    path_XYs = regularize_curves(path_XYs)
    path_XYs = detect_symmetry(path_XYs)
    write_csv(output_csv, path_XYs)

# Example of processing based on the input categories:

# Isolated Shapes
process_isolated_shapes('master_doodle_dataframe.csv', 'examples/isolated_sol.csv')

# Fragmented Shapes
process_fragmented_shapes(['examples/frag0.csv', 'examples/frag1.csv'], 'examples/frag01_sol.csv')
process_fragmented_shapes(['examples/frag2.csv'], 'examples/frag2_sol.csv')

# Connected Occlusion
process_connected_occlusion('examples/occlusion1.csv', 'examples/occlusion1_sol.csv')

# Disconnected Occlusion
process_disconnected_occlusion('examples/occlusion2.csv', 'examples/occlusion2_sol.csv')

# Generate SVG and PNG
path_XYs = read_csv('examples/isolated_sol.csv')
polylines2svg(path_XYs, 'output_isolated.svg')

path_XYs = read_csv('examples/frag01_sol.csv')
polylines2svg(path_XYs, 'output_fragmented.svg')

path_XYs = read_csv('examples/occlusion1_sol.csv')
polylines2svg(path_XYs, 'output_connected_occlusion.svg')

path_XYs = read_csv('examples/occlusion2_sol.csv')
polylines2svg(path_XYs, 'output_disconnected_occlusion.svg')

# Generate solution files
process_isolated_shapes('master_doodle_dataframe.csv', 'examples/isolated_sol.csv')
process_fragmented_shapes(['examples/frag0.csv', 'examples/frag1.csv'], 'examples/frag01_sol.csv')
process_fragmented_shapes(['examples/frag2.csv'], 'examples/frag2_sol.csv')
process_connected_occlusion('examples/occlusion1.csv', 'examples/occlusion1_sol.csv')
process_disconnected_occlusion('examples/occlusion2.csv', 'examples/occlusion2_sol.csv')

print("Solution files have been generated.")

import numpy as np

def generate_rectangle_csv(file_path):
    # Define a rectangle with four corners
    rectangle = np.array([
        [0, 0], [1, 0], [1, 1], [0, 1], [0, 0]  # Closing the rectangle
    ])
    np.savetxt(file_path, rectangle, delimiter=',')

def generate_circle_csv(file_path):
    # Define a circle using parametric equations
    theta = np.linspace(0, 2*np.pi, 100)
    circle = np.vstack((np.cos(theta), np.sin(theta))).T
    np.savetxt(file_path, circle, delimiter=',')

# Generate the CSV files
generate_rectangle_csv('examples/frag0.csv')  # Rectangle shape
generate_circle_csv('examples/frag1.csv')    # Circle shape

print("CSV files 'frag0.csv' and 'frag1.csv' generated in the 'examples' directory.")

import numpy as np
import os
from google.colab import files

# Create a directory to store the examples if it doesn't exist
os.makedirs('examples', exist_ok=True)

def generate_rectangle_csv(file_path):
    # Define a rectangle with four corners
    rectangle = np.array([
        [0, 0], [1, 0], [1, 1], [0, 1], [0, 0]  # Closing the rectangle
    ])
    np.savetxt(file_path, rectangle, delimiter=',')

def generate_circle_csv(file_path):
    # Define a circle using parametric equations
    theta = np.linspace(0, 2*np.pi, 100)
    circle = np.vstack((np.cos(theta), np.sin(theta))).T
    np.savetxt(file_path, circle, delimiter=',')

# Generate the CSV files in the 'examples' directory
generate_rectangle_csv('examples/frag0.csv')  # Rectangle shape
generate_circle_csv('examples/frag1.csv')    # Circle shape

# Print confirmation
print("CSV files 'frag0.csv' and 'frag1.csv' generated in the 'examples' directory.")

# Download the generated files
files.download('examples/frag0.csv')
files.download('examples/frag1.csv')

import svgwrite
import cairosvg
import numpy as np

def polylines2svg(paths_XYs, svg_path):
    W, H = 0, 0
    for path_XYs in paths_XYs:
        for XY in path_XYs:
            W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))

    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)

    # Create a new SVG drawing
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()

    colours = ['red', 'green', 'blue', 'orange', 'purple']  # Define some colors for paths
    for i, path in enumerate(paths_XYs):
        path_data = []
        c = colours[i % len(colours)]
        for XY in path:
            path_data.append(("M", (XY[0, 0], XY[0, 1])))
            for j in range(1, len(XY)):
                path_data.append(("L", (XY[j, 0], XY[j, 1])))
            if not np.allclose(XY[0], XY[-1]):
                path_data.append(("Z", None))
        group.add(dwg.path(d=path_data, fill=c, stroke='none', stroke_width=2))

    dwg.add(group)
    dwg.save()

    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(
        url=svg_path,
        write_to=png_path,
        parent_width=W,
        parent_height=H,
        output_width=fact * W,
        output_height=fact * H,
        background_color='white'
    )
    return

import svgwrite
import cairosvg
import numpy as np
import IPython.display as display
from PIL import Image

def polylines2svg(paths_XYs, svg_path):
    W, H = 0, 0
    for path_XYs in paths_XYs:
        for XY in path_XYs:
            W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))

    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)

    # Create a new SVG drawing
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()

    colours = ['red', 'green', 'blue', 'orange', 'purple']  # Define some colors for paths
    for i, path in enumerate(paths_XYs):
        path_data = []
        c = colours[i % len(colours)]
        for XY in path:
            path_data.append(("M", (XY[0, 0], XY[0, 1])))
            for j in range(1, len(XY)):
                path_data.append(("L", (XY[j, 0], XY[j, 1])))
            if not np.allclose(XY[0], XY[-1]):
                path_data.append(("Z", None))
        group.add(dwg.path(d=path_data, fill=c, stroke='none', stroke_width=2))

    dwg.add(group)
    dwg.save()

    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(
        url=svg_path,
        write_to=png_path,
        parent_width=W,
        parent_height=H,
        output_width=fact * W,
        output_height=fact * H,
        background_color='white'
    )
    return png_path

# Use the function to generate the SVG and PNG files
paths_XYs = [np.array([[[0, 0], [100, 0], [100, 100], [0, 100], [0, 0]]])]
png_path = polylines2svg(paths_XYs, 'output.svg')

# Display the PNG image in the notebook
image = Image.open(png_path)
display.display(image)

import numpy as np
import matplotlib.pyplot as plt

# Step 1: Generate Doodle-Like Polylines
def generate_doodle(num_lines=5, points_per_line=10, x_range=(0, 100), y_range=(0, 100)):
    doodle = []
    for _ in range(num_lines):
        # Generate random points for each line
        x = np.random.uniform(x_range[0], x_range[1], points_per_line)
        y = np.random.uniform(y_range[0], y_range[1], points_per_line)
        doodle.append(np.column_stack((x, y)))  # Combine x and y into a single array
    return doodle

# Generate a doodle
doodle_paths = generate_doodle()

# Plot the doodle
plt.figure(figsize=(6, 6))
for path in doodle_paths:
    plt.plot(path[:, 0], path[:, 1], linewidth=2)
plt.title('Generated Doodle')
plt.axis('equal')
plt.show()

# Step 2: Classify the Doodle
def classify_doodle(doodle_paths):
    # Simple classification logic based on the number of lines
    num_lines = len(doodle_paths)
    if num_lines == 1:
        return "Isolated shape"
    elif num_lines > 1 and num_lines <= 3:
        return "Fragmented shape"
    else:
        return "Complex shape with multiple fragments"

# Classify the generated doodle
classification = classify_doodle(doodle_paths)
print(f"The generated doodle is classified as: {classification}")

import numpy as np
import pandas as pd

# Step 1: Create Input Polylines as CSV

# Create an isolated shape (rectangle)
isolated_shape = np.array([[1, 1], [1, 4], [4, 4], [4, 1], [1, 1]])  # Rectangle
pd.DataFrame(isolated_shape, columns=['X', 'Y']).to_csv('examples/isolated.csv', index=False)

# Create a fragmented shape (two lines)
fragmented_shape = np.array([[1, 1], [2, 2], [3, 1], [4, 2], [4, 5]])  # Line 1
fragmented_shape2 = np.array([[2, 3], [3, 4], [3, 3]])  # Line 2
pd.DataFrame(fragmented_shape, columns=['X', 'Y']).to_csv('examples/frag0.csv', index=False)
pd.DataFrame(fragmented_shape2, columns=['X', 'Y']).to_csv('examples/frag1.csv', index=False)

# Create a connected occlusion shape
connected_occlusion = np.array([[1, 1], [1, 4], [2, 4], [2, 1], [1, 1], [2, 3], [3, 3]])  # Occlusion
pd.DataFrame(connected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion1.csv', index=False)

print("CSV files created successfully.")

# Step 2: Classify the Polylines from the CSV Files

def read_polylines(csv_path):
    return pd.read_csv(csv_path).to_numpy()

def classify_polylines(polylines):
    # Classify based on the number of unique polylines
    unique_shapes = np.unique(polylines, axis=0)
    num_shapes = len(unique_shapes)

    if num_shapes == 1:
        return "Isolated shape"
    elif num_shapes > 1 and num_shapes <= 3:
        return "Fragmented shape"
    else:
        return "Complex shape with multiple fragments"

# Load and classify each shape
# Isolated shape
isolated_polylines = read_polylines('examples/isolated.csv')
print(f'Isolated Shape Classification: {classify_polylines(isolated_polylines)}')

# Fragmented shape
frag0_polylines = read_polylines('examples/frag0.csv')
frag1_polylines = read_polylines('examples/frag1.csv')
print(f'Fragmented Shape 0 Classification: {classify_polylines(frag0_polylines)}')
print(f'Fragmented Shape 1 Classification: {classify_polylines(frag1_polylines)}')

# Connected occlusion shape
connected_occlusion_polylines = read_polylines('examples/occlusion1.csv')
print(f'Connected Occlusion Shape Classification: {classify_polylines(connected_occlusion_polylines)}')

import numpy as np
import pandas as pd

# Step 1: Create Input Polylines as CSV

# Create an isolated shape (rectangle)
isolated_shape = np.array([[1, 1], [1, 4], [4, 4], [4, 1], [1, 1]])  # Rectangle
pd.DataFrame(isolated_shape, columns=['X', 'Y']).to_csv('examples/isolated.csv', index=False)

# Create a fragmented shape (two lines)
fragmented_shape = np.array([[1, 1], [2, 2], [3, 1], [4, 2], [4, 5]])  # Line 1
fragmented_shape2 = np.array([[2, 3], [3, 4], [3, 3]])  # Line 2
pd.DataFrame(fragmented_shape, columns=['X', 'Y']).to_csv('examples/frag0.csv', index=False)
pd.DataFrame(fragmented_shape2, columns=['X', 'Y']).to_csv('examples/frag1.csv', index=False)

# Create a connected occlusion shape
connected_occlusion = np.array([[1, 1], [1, 4], [2, 4], [2, 1], [1, 1], [2, 3], [3, 3]])  # Occlusion
pd.DataFrame(connected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion1.csv', index=False)

# Create a disconnected occlusion shape
disconnected_occlusion = np.array([[1, 1], [1, 2], [2, 1], [3, 3], [4, 4], [4, 1], [3, 2]])  # Disconnected
pd.DataFrame(disconnected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion2.csv', index=False)

print("CSV files created successfully.")

# Step 2: Read and Classify the Polylines from the CSV Files

def read_polylines(csv_path):
    return pd.read_csv(csv_path).to_numpy()

def classify_polylines(polylines):
    unique_shapes = np.unique(polylines, axis=0)
    num_shapes = len(unique_shapes)

    if num_shapes == 1:
        return "Isolated shape"
    elif num_shapes > 1 and num_shapes <= 3:
        return "Fragmented shape"
    elif num_shapes > 3 and is_connected(polylines):
        return "Connected occlusion shape"
    elif num_shapes > 3 and not is_connected(polylines):
        return "Disconnected occlusion shape"
    else:
        return "Complex shape with multiple fragments"

def is_connected(polylines):
    # Check if the last point of one polyline connects to the first point of another
    for i in range(len(polylines) - 1):
        if np.array_equal(polylines[i][-1], polylines[i + 1][0]):
            return True
    return False

# Load and classify each shape
# Isolated shape
isolated_polylines = read_polylines('examples/isolated.csv')
print(f'Isolated Shape Classification: {classify_polylines(isolated_polylines)}')

# Fragmented shapes
frag0_polylines = read_polylines('examples/frag0.csv')
frag1_polylines = read_polylines('examples/frag1.csv')
print(f'Fragmented Shape 0 Classification: {classify_polylines(frag0_polylines)}')
print(f'Fragmented Shape 1 Classification: {classify_polylines(frag1_polylines)}')

# Connected occlusion shape
connected_occlusion_polylines = read_polylines('examples/occlusion1.csv')
print(f'Connected Occlusion Shape Classification: {classify_polylines(connected_occlusion_polylines)}')

# Disconnected occlusion shape
disconnected_occlusion_polylines = read_polylines('examples/occlusion2.csv')
print(f'Disconnected Occlusion Shape Classification: {classify_polylines(disconnected_occlusion_polylines)}')

# Step 3: Implement Curve Regularization (Placeholder)
def regularize_curve(polylines):
    # Implement regularization logic here
    return polylines  # Return regularized polylines

# Step 4: Implement Symmetry Detection (Placeholder)
def detect_symmetry(polylines):
    # Implement symmetry detection logic here
    return True  # Return whether the shape is symmetric or not

# Process and evaluate curves
for csv_file in ['examples/isolated.csv', 'examples/frag0.csv', 'examples/frag1.csv',
                 'examples/occlusion1.csv', 'examples/occlusion2.csv']:
    polylines = read_polylines(csv_file)
    regularized_polylines = regularize_curve(polylines)
    symmetry = detect_symmetry(regularized_polylines)
    print(f'Processed {csv_file} - Regularized: {regularized_polylines}, Symmetric: {symmetry}')

import numpy as np
import pandas as pd

# Step 1: Create Input Polylines as CSV

# Create an isolated shape (rectangle)
isolated_shape = np.array([[1, 1], [1, 4], [4, 4], [4, 1], [1, 1]])  # Rectangle
pd.DataFrame(isolated_shape, columns=['X', 'Y']).to_csv('examples/isolated.csv', index=False)

# Create a fragmented shape (two lines)
fragmented_shape = np.array([[1, 1], [2, 2], [3, 1], [4, 2], [4, 5]])  # Line 1
fragmented_shape2 = np.array([[2, 3], [3, 4], [3, 3]])  # Line 2
pd.DataFrame(fragmented_shape, columns=['X', 'Y']).to_csv('examples/frag0.csv', index=False)
pd.DataFrame(fragmented_shape2, columns=['X', 'Y']).to_csv('examples/frag1.csv', index=False)

# Create a connected occlusion shape
connected_occlusion = np.array([[1, 1], [1, 4], [2, 4], [2, 1], [1, 1], [2, 3], [3, 3]])  # Occlusion
pd.DataFrame(connected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion1.csv', index=False)

# Create a disconnected occlusion shape
disconnected_occlusion = np.array([[1, 1], [1, 2], [2, 1], [3, 3], [4, 4], [4, 1], [3, 2]])  # Disconnected
pd.DataFrame(disconnected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion2.csv', index=False)

print("CSV files created successfully.")

# Step 2: Read and Classify the Polylines from the CSV Files

def read_polylines(csv_path):
    return pd.read_csv(csv_path).to_numpy()

def classify_polylines(polylines):
    unique_shapes = np.unique(polylines, axis=0)
    num_shapes = len(unique_shapes)

    if num_shapes == 1:
        return "Isolated shape"
    elif num_shapes > 1 and num_shapes <= 3:
        return "Fragmented shape"
    elif num_shapes > 3 and is_connected(polylines):
        return "Connected occlusion shape"
    elif num_shapes > 3 and not is_connected(polylines):
        return "Disconnected occlusion shape"
    else:
        return "Complex shape with multiple fragments"

def is_connected(polylines):
    # Check if the last point of one polyline connects to the first point of another
    for i in range(len(polylines) - 1):
        if np.array_equal(polylines[i][-1], polylines[i + 1][0]):
            return True
    return False

# Load and classify each shape
# Isolated shape
isolated_polylines = read_polylines('examples/isolated.csv')
print(f'Isolated Shape Classification: {classify_polylines(isolated_polylines)}')

# Fragmented shapes
frag0_polylines = read_polylines('examples/frag0.csv')
frag1_polylines = read_polylines('examples/frag1.csv')
print(f'Fragmented Shape 0 Classification: {classify_polylines(frag0_polylines)}')
print(f'Fragmented Shape 1 Classification: {classify_polylines(frag1_polylines)}')

# Connected occlusion shape
connected_occlusion_polylines = read_polylines('examples/occlusion1.csv')
print(f'Connected Occlusion Shape Classification: {classify_polylines(connected_occlusion_polylines)}')

# Disconnected occlusion shape
disconnected_occlusion_polylines = read_polylines('examples/occlusion2.csv')
print(f'Disconnected Occlusion Shape Classification: {classify_polylines(disconnected_occlusion_polylines)}')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Step 1: Create Input Polylines as CSV

# Create an isolated shape (rectangle)
isolated_shape = np.array([[1, 1], [1, 4], [4, 4], [4, 1], [1, 1]])  # Rectangle
pd.DataFrame(isolated_shape, columns=['X', 'Y']).to_csv('examples/isolated.csv', index=False)

# Create a fragmented shape (two lines)
fragmented_shape = np.array([[1, 1], [2, 2], [3, 1], [4, 2], [4, 5]])  # Line 1
fragmented_shape2 = np.array([[2, 3], [3, 4], [3, 3]])  # Line 2
pd.DataFrame(fragmented_shape, columns=['X', 'Y']).to_csv('examples/frag0.csv', index=False)
pd.DataFrame(fragmented_shape2, columns=['X', 'Y']).to_csv('examples/frag1.csv', index=False)

# Create a connected occlusion shape
connected_occlusion = np.array([[1, 1], [1, 4], [2, 4], [2, 1], [1, 1], [2, 3], [3, 3]])  # Occlusion
pd.DataFrame(connected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion1.csv', index=False)

# Create a disconnected occlusion shape
disconnected_occlusion = np.array([[1, 1], [1, 2], [2, 1], [3, 3], [4, 4], [4, 1], [3, 2]])  # Disconnected
pd.DataFrame(disconnected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion2.csv', index=False)

print("CSV files created successfully.")

# Step 2: Read and Classify the Polylines from the CSV Files

def read_polylines(csv_path):
    return pd.read_csv(csv_path).to_numpy()

def classify_polylines(polylines):
    unique_shapes = np.unique(polylines, axis=0)
    num_shapes = len(unique_shapes)

    if num_shapes == 1:
        return "Isolated shape"
    elif num_shapes > 1 and num_shapes <= 3:
        return "Fragmented shape"
    elif num_shapes > 3 and is_connected(polylines):
        return "Connected occlusion shape"
    elif num_shapes > 3 and not is_connected(polylines):
        return "Disconnected occlusion shape"
    else:
        return "Complex shape with multiple fragments"

def is_connected(polylines):
    # Check if the last point of one polyline connects to the first point of another
    for i in range(len(polylines) - 1):
        if np.array_equal(polylines[i][-1], polylines[i + 1][0]):
            return True
    return False

# Step 3: Visualize the Shapes

def plot_polylines(polylines, title):
    plt.figure(figsize=(6, 6))
    plt.plot(polylines[:, 0], polylines[:, 1], marker='o')
    plt.title(title)
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid()
    plt.axis('equal')
    plt.show()

# Load and classify each shape
# Isolated shape
isolated_polylines = read_polylines('examples/isolated.csv')
print(f'Isolated Shape Classification: {classify_polylines(isolated_polylines)}')
plot_polylines(isolated_polylines, "Isolated Shape (Rectangle)")

# Fragmented shapes
frag0_polylines = read_polylines('examples/frag0.csv')
frag1_polylines = read_polylines('examples/frag1.csv')
print(f'Fragmented Shape 0 Classification: {classify_polylines(frag0_polylines)}')
plot_polylines(frag0_polylines, "Fragmented Shape 0")

print(f'Fragmented Shape 1 Classification: {classify_polylines(frag1_polylines)}')
plot_polylines(frag1_polylines, "Fragmented Shape 1")

# Connected occlusion shape
connected_occlusion_polylines = read_polylines('examples/occlusion1.csv')
print(f'Connected Occlusion Shape Classification: {classify_polylines(connected_occlusion_polylines)}')
plot_polylines(connected_occlusion_polylines, "Connected Occlusion Shape")

# Disconnected occlusion shape
disconnected_occlusion_polylines = read_polylines('examples/occlusion2.csv')
print(f'Disconnected Occlusion Shape Classification: {classify_polylines(disconnected_occlusion_polylines)}')
plot_polylines(disconnected_occlusion_polylines, "Disconnected Occlusion Shape")

import numpy as np
import pandas as pd
import svgwrite
import cairosvg
import os

# Step 1: Create Input Polylines as CSV
os.makedirs('examples', exist_ok=True)

# Create an isolated shape (rectangle)
isolated_shape = np.array([[1, 1], [1, 4], [4, 4], [4, 1], [1, 1]])  # Rectangle
pd.DataFrame(isolated_shape, columns=['X', 'Y']).to_csv('examples/isolated.csv', index=False)

# Create a fragmented shape (two lines)
fragmented_shape = np.array([[1, 1], [2, 2], [3, 1], [4, 2], [4, 5]])  # Line 1
fragmented_shape2 = np.array([[2, 3], [3, 4], [3, 3]])  # Line 2
pd.DataFrame(fragmented_shape, columns=['X', 'Y']).to_csv('examples/frag0.csv', index=False)
pd.DataFrame(fragmented_shape2, columns=['X', 'Y']).to_csv('examples/frag1.csv', index=False)

# Create a connected occlusion shape
connected_occlusion = np.array([[1, 1], [1, 4], [2, 4], [2, 1], [1, 1], [2, 3], [3, 3]])  # Occlusion
pd.DataFrame(connected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion1.csv', index=False)

# Create a disconnected occlusion shape
disconnected_occlusion = np.array([[1, 1], [2, 1], [2, 4], [4, 4], [4, 1], [3, 3], [1, 3]])  # Disconnected
pd.DataFrame(disconnected_occlusion, columns=['X', 'Y']).to_csv('examples/occlusion2.csv', index=False)

print("CSV files created successfully.")

# Step 2: Classify the Polylines from the CSV Files
def read_polylines(csv_path):
    return pd.read_csv(csv_path).to_numpy()

def classify_polylines(polylines):
    # Classify based on the number of unique polylines
    unique_shapes = np.unique(polylines, axis=0)
    num_shapes = len(unique_shapes)

    if num_shapes == 1:
        return "Isolated shape"
    elif num_shapes > 1 and num_shapes <= 3:
        return "Fragmented shape"
    else:
        return "Complex shape with multiple fragments"

# Load and classify each shape
# Isolated shape
isolated_polylines = read_polylines('examples/isolated.csv')
print(f'Isolated Shape Classification: {classify_polylines(isolated_polylines)}')

# Fragmented shape
frag0_polylines = read_polylines('examples/frag0.csv')
frag1_polylines = read_polylines('examples/frag1.csv')
print(f'Fragmented Shape 0 Classification: {classify_polylines(frag0_polylines)}')
print(f'Fragmented Shape 1 Classification: {classify_polylines(frag1_polylines)}')

# Connected occlusion shape
connected_occlusion_polylines = read_polylines('examples/occlusion1.csv')
print(f'Connected Occlusion Shape Classification: {classify_polylines(connected_occlusion_polylines)}')

# Disconnected occlusion shape
disconnected_occlusion_polylines = read_polylines('examples/occlusion2.csv')
print(f'Disconnected Occlusion Shape Classification: {classify_polylines(disconnected_occlusion_polylines)}')

# Step 3: Rasterize the shapes
def polylines2svg(paths_XYs, svg_path):
    W, H = 0, 0
    for XY in paths_XYs:
        W, H = max(W, np.max(XY[:, 0])), max(H, np.max(XY[:, 1]))

    padding = 0.1
    W, H = int(W + padding * W), int(H + padding * H)

    # Create a new SVG drawing
    dwg = svgwrite.Drawing(svg_path, profile='tiny', shape_rendering='crispEdges')
    group = dwg.g()

    colours = ['red', 'green', 'blue', 'yellow', 'cyan', 'magenta']
    for i, XY in enumerate(paths_XYs):
        path_data = []
        c = colours[i % len(colours)]
        path_data.append(("M", (XY[0, 0], XY[0, 1])))
        for j in range(1, len(XY)):
            path_data.append(("L", (XY[j, 0], XY[j, 1])))
        if not np.allclose(XY[0], XY[-1]):
            path_data.append(("Z", None))

        group.add(dwg.path(d=path_data, fill=c, stroke='none', stroke_width=2))

    dwg.add(group)
    dwg.save()

    png_path = svg_path.replace('.svg', '.png')
    fact = max(1, 1024 // min(H, W))
    cairosvg.svg2png(url=svg_path, write_to=png_path, parent_width=W, parent_height=H,
                      output_width=fact * W, output_height=fact * H, background_color='white')
    return png_path

# Step 4: Rasterize the shapes and display the images
shapes = [
    (isolated_polylines, 'examples/isolated.svg'),
    (frag0_polylines, 'examples/frag0.svg'),
    (frag1_polylines, 'examples/frag1.svg'),
    (connected_occlusion_polylines, 'examples/occlusion1.svg'),
    (disconnected_occlusion_polylines, 'examples/occlusion2.svg'),
]

for shape, svg_file in shapes:
    png_file = polylines2svg([shape], svg_file)  # Pass shape directly
    print(f"Rasterized image saved as: {png_file}")

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# List of PNG files to display
png_files = [
    'examples/isolated.png',
    'examples/frag0.png',
    'examples/frag1.png',
    'examples/occlusion1.png',
    'examples/occlusion2.png',
]

# Display each image
for png_file in png_files:
    img = mpimg.imread(png_file)
    plt.figure(figsize=(5, 5))
    plt.imshow(img)
    plt.axis('off')  # Hide axes
    plt.title(png_file)  # Title for the image
    plt.show()

